// src/lib/quoteToken.ts
import "server-only";
import { createHmac, timingSafeEqual } from "crypto";

/**
 * @typedef {Object} QuotePayloadV1
 * @property {1} v
 * @property {string} routeId
 * @property {string} journeyId
 * @property {string} date            // YYYY-MM-DD
 * @property {number} qty
 * @property {number} base_cents      // per-seat, cents
 * @property {number} tax_cents       // per-seat, cents
 * @property {number} fees_cents      // per-seat, cents
 * @property {number} total_cents     // party total, cents
 * @property {string} currency        // e.g. "GBP"
 * @property {number} iat             // seconds
 * @property {number} exp             // seconds
 */

// ---- base64url helpers ----
const b64url = {
  enc(input) {
    const buf = Buffer.isBuffer(input) ? input : Buffer.from(input);
    return buf
      .toString("base64")
      .replace(/=/g, "")
      .replace(/\+/g, "-")
      .replace(/\//g, "_");
  },
  encJson(obj) {
    return b64url.enc(Buffer.from(JSON.stringify(obj), "utf8"));
  },
  decToBuf(b64u) {
    const padLen = 4 - (b64u.length % 4 || 4);
    const base64 =
      b64u.replace(/-/g, "+").replace(/_/g, "/") +
      "=".repeat(padLen === 4 ? 0 : padLen);
    return Buffer.from(base64, "base64");
  },
};

function hmac256(secret, data) {
  return createHmac("sha256", secret).update(data).digest();
}

function coerceNumbers(p) {
  return {
    ...p,
    qty: Number(p.qty),
    base_cents: Number(p.base_cents),
    tax_cents: Number(p.tax_cents),
    fees_cents: Number(p.fees_cents),
    total_cents: Number(p.total_cents),
    iat: Number(p.iat),
    exp: Number(p.exp),
  };
}

/**
 * Sign a quote payload (HS256 JWT).
 * @param {QuotePayloadV1} payload
 * @param {{secret?: string}} [opts]
 * @returns {Promise<string>}
 */
export async function signQuote(payload, opts) {
  const secret = opts?.secret ?? process.env.QUOTE_SIGNING_SECRET ?? "";
  if (!secret) throw new Error("QUOTE_SIGNING_SECRET missing to sign token");

  const header = { alg: "HS256", typ: "JWT" };
  const encHeader = b64url.encJson(header);
  const encPayload = b64url.encJson(payload);
  const signingInput = `${encHeader}.${encPayload}`;
  const sig = hmac256(secret, signingInput);
  const encSig = b64url.enc(sig);
  return `${signingInput}.${encSig}`;
}

/**
 * Verify a token. Checks signature and exp/iat sanity.
 * @param {string} token
 * @param {{secret?: string}} [opts]
 * @returns {Promise<{ok:true,payload:QuotePayloadV1}|{ok:false,error:string}>}
 */
export async function verifyQuote(token, opts) {
  try {
    if (typeof token !== "string" || token.trim().length < 20) {
      return { ok: false, error: "token_missing_or_too_short" };
    }

    const secret = opts?.secret ?? process.env.QUOTE_SIGNING_SECRET ?? "";
    if (!secret) return { ok: false, error: "secret_missing" };

    const parts = token.split(".");
    if (parts.length !== 3) return { ok: false, error: "jwt_malformed" };

    const [encHeader, encPayload, encSig] = parts;
    const signingInput = `${encHeader}.${encPayload}`;
    const expected = hmac256(secret, signingInput);
    const got = b64url.decToBuf(encSig);

    if (expected.length !== got.length || !timingSafeEqual(expected, got)) {
      return { ok: false, error: "bad_signature" };
    }

    const payloadJson = b64url.decToBuf(encPayload).toString("utf8");
    const raw = JSON.parse(payloadJson);
    const payload = coerceNumbers(raw);

    if (!payload?.v || payload.v !== 1) return { ok: false, error: "unsupported_version" };
    if (!payload.routeId || !payload.date || !payload.qty) {
      return { ok: false, error: "payload_missing_required_fields" };
    }

    const now = Math.floor(Date.now() / 1000);
    const skew = 120; // 2 minutes
    if (typeof payload.exp !== "number" || payload.exp < now - skew) {
      return { ok: false, error: "expired" };
    }
    if (typeof payload.iat !== "number" || payload.iat > now + skew) {
      return { ok: false, error: "iat_in_future" };
    }

    return { ok: true, payload };
  } catch (e) {
    return { ok: false, error: String(e?.message || "verify_exception") };
  }
}

/**
 * Convert the payload back to per-seat all-in (units).
 * @param {QuotePayloadV1} p
 */
export function perSeatAllInFromPayload(p) {
  if (!p || typeof p.total_cents !== "number" || typeof p.qty !== "number" || p.qty <= 0) return 0;
  return p.total_cents / p.qty / 100;
}
